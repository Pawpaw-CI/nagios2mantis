#!/usr/bin/python
#
# Copyright (C) 2013 Cyril Bouthors <cyril@boutho.rs>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
#

from ConfigParser import RawConfigParser
import argparse
import yaml
from sys import exit
import sqlite3
from SOAPpy import WSDL, faultType
import os
import logging
import sys

logging.basicConfig(stream=sys.stdout)

NAGIOS_STATES = ['UP', 'DOWN', 'CRITICAL', 'WARNING', 'OK', 'UNKNOWN',
                 'PENDING']


class Config(RawConfigParser):
    def __init__(self, configuration_file):
        RawConfigParser.__init__(self)
        self.read(configuration_file)

        self.wsdl = self.get('Mantis', 'wsdl')
        self.username = self.get('Mantis', 'username')
        self.password = self.get('Mantis', 'password')
        self.project_id = self.get('Mantis', 'default_mantis_project_id')
        self.issue_description = unicode(self.get(
            'Mantis', 'issue_description'), 'UTF-8')
        self.category_name = unicode(self.get('Mantis', 'category_name'),
                                     'UTF-8')
        self.sqlite_file = self.get('Mantis2nagios', 'sqlite_file')
        self.inotify_file = self.get('Mantis2nagios', 'inotify_file')


def get_summary(hostname, state, service):
    # Host alert
    if service is None:
        return '{hostname} is {state}'.format(
            hostname=hostname,
            state=state,
        )
    # Service alert
    return '{service} is {state} on host {hostname}'.format(
        service=service,
        state=state,
        hostname=hostname,
    )


def empty(args):
    config = Config(args.configuration_file)

    mantis = WSDL.Proxy(config.wsdl)
    db_spool = DbSpool(config.sqlite_file)
    for row in db_spool.rows():
        row_id, hostname, state, service, plugin_output, project_id = row

        summary = get_summary(hostname, state, service)

        try:
            # Find an existing issue
            issue_id = db_spool.get_issue_id(hostname, service)
            try:
                issue = mantis.mc_issue_get(
                    config.username,
                    config.password,
                    issue_id
                )
            except faultType:
                issue = None
            if issue is None or issue['status']['id'] in [80, 90]:
                db_spool.del_relation(hostname, service)
                issue_id = None
                issue = None
            # if an issue already exists
            if issue is None:
                issue = {
                    'summary': summary,
                    'description': config.issue_description.format(
                        plugin_output=plugin_output
                    ),
                    'category': config.category_name,
                    'project': {
                        'id': project_id
                    },
                }
                # Open Mantis issue
                logging.info('Add an issue \'%s\'', issue['summary'])
                issue_id = mantis.mc_issue_add(
                    config.username,
                    config.password,
                    issue
                )
                db_spool.add_relation(hostname, service, issue_id)
            else:
                # Add a note
                logging.info('Add a note \'%s\' to issue %d', summary,
                            issue_id)
                mantis.mc_issue_note_add(
                    config.username,
                    config.password,
                    issue_id,
                    {'text': summary}
                )
        except:
            logging.exception('An error occured with Mantis webservice')
        else:
            db_spool.delete(row_id)

    db_spool.close()


def spool(args):
    config = Config(args.configuration_file)
    # Open a Mantis issue only if Nagios sends a problem notification. Issues
    # are closed by the staff
    if args.notification_type == 'RECOVERY':
        exit()

    # Parse args.host_notes
    if args.host_notes is not None and args.host_notes is not '':
        host_notes = yaml.load(args.host_notes)
        project_id = host_notes['mantis_project_id']
    else:
        project_id = config.project_id

    db_spool = DbSpool(config.sqlite_file)
    db_spool.add(args.hostname, args.state, args.service, args.plugin_output,
                 project_id)
    db_spool.close()

    if os.path.exists(config.inotify_file):
        os.utime(config.inotify_file, None)
    else:
        open(config.inotify_file, 'w').close()


class DbSpool(object):
    def __init__(self, sqlite_file):
        self.db = sqlite3.connect(sqlite_file)
        self.db.execute('''create table if not exists nagios2mantis (
id integer primary key,
hostname text,
state text,
service text,
plugin_output text,
project_id integer);''')
        self.db.execute('create table if not exists nagios_mantis_relation('
                        'hostname text, service text, issue_id integer)')

    def add_relation(self, hostname, service, issue_id):
        db_issue_id = self.get_issue_id(hostname, service)
        assert not db_issue_id, 'A relation for hostname %s and service %s and '\
            'with issue_id %d already exists' % (hostname, service, issue_id)

        params = {
            'hostname': hostname,
            'service': service,
            'issue_id': issue_id
        }
        self.db.execute(
            'insert into nagios_mantis_relation (hostname, service, issue_id) '
            'values (:hostname, :service, :issue_id);',
            params
        )
        self.db.commit()

    def get_issue_id(self, hostname, service):
        cursor = self.db.cursor()
        cursor.execute(
            'select issue_id from nagios_mantis_relation where '
            'hostname = :hostname and service = :service',
            {'hostname': hostname, 'service': service}
        )
        try:
            rows = cursor.fetchall()
            assert len(rows) <= 1, 'More than one issue found for hostname %s '\
                'and service %s' % [hostname, service]
            if len(rows) == 0:
                return None
            return rows[0][0]
        finally:
            cursor.close()

    def del_relation(self, hostname, service):
        self.db.execute(
            'DELETE FROM nagios_mantis_relation WHERE '
            'hostname = :hostname and service = :service;',
            {'hostname': hostname, 'service': service}
        )
        self.db.commit()

    def close(self):
        self.db.close()

    def add(self, hostname, state, service, plugin_output, project_id):
        request_params = {
            'hostname': hostname,
            'state': state,
            'service': service,
            'plugin_output': plugin_output,
            'project_id': project_id
        }
        self.db.execute('insert into nagios2mantis (hostname, state, service,'
                        'plugin_output, project_id) values (:hostname, :state,'
                        ':service, :plugin_output, :project_id);',
                        request_params)
        self.db.commit()

    def rows(self):
        cursor = self.db.cursor()
        cursor.execute('SELECT id, hostname, state, service, plugin_output, '
                       'project_id FROM nagios2mantis')
        try:
            return cursor.fetchall()
        finally:
            cursor.close()

    def delete(self, id):
        self.db.execute('DELETE FROM nagios2mantis WHERE id = :id;',
                        {'id': id})
        self.db.commit()

    def rollback(self):
        self.db.rollback()


def main():
    # Read command line arguments
    parser = argparse.ArgumentParser(
        description='Sends Nagios alerts to Mantis')
    parser.add_argument(
        '--configuration-file',
        help='INI file containing Mantis parameters',
        default='/etc/nagios2mantis.ini'
    )
    subparsers = parser.add_subparsers()

    empty_parser = subparsers.add_parser('empty')
    empty_parser.set_defaults(func=empty)

    spool_parser = subparsers.add_parser('spool')
    spool_parser.add_argument(
        '--hostname',
        help='Nagios hostname',
        required=True
    )
    spool_parser.add_argument(
        '--service',
        help='Nagios service. ' +
        'Do not define the service if the alerts is about a host'
    )
    spool_parser.add_argument(
        '--notification-type',
        help='Nagios notification type',
        choices=['PROBLEM', 'RECOVERY'],
        required=True
    )
    spool_parser.add_argument(
        '--state',
        help='Nagios service or host state',
        choices=NAGIOS_STATES,
        required=True
    )
    spool_parser.add_argument(
        '--plugin-output',
        help='Nagios plugin output',
        required=True
    )
    spool_parser.add_argument(
        '--host-notes',
        help='Nagios host notes: YAML formatted mantis_project_id'
    )
    spool_parser.set_defaults(func=spool)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
